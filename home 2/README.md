# Проект: Аналіз алгоритму побудови Коду Ґрея та вирішення задач LeetCode

## Завдання 1: Доведення коректності та обчислення складності алгоритму побудови Коду Ґрея

## Алгоритм побудови коду Ґрея ґрунтується на рекурсивному підході:

1. **База рекурсії**: для `n = 1` отримуємо дві послідовності: `0` та `1`, які відрізняються рівно в одному біті.
2. **Рекурсивний крок**: для `n > 1` виконуємо такі дії:
   - Будуємо код Ґрея для `n-1`.
   - До кожного елемента першої половини додаємо на початок `0`.
   - До кожного елемента другої половини (дзеркальної копії першої) додаємо на початок `1`.

## Доведення коректності

Доведемо правильність алгоритму методом математичної індукції.

### База індукції

Для `n = 1` отримуємо послідовність `0, 1`, яка коректно задовольняє умову: сусідні рядки відрізняються рівно в одному біті.

### Індукційний крок

Припустимо, що для деякого `n - 1` алгоритм будує коректний код Ґрея, тобто будь-які два сусідні коди відрізняються рівно в одному біті.

Розглянемо, як формується код Ґрея для `n`:
- **Перша половина** містить код Ґрея для `n-1` з доданим спереду бітом `0`. Це не порушує властивості, оскільки зміни відбуваються лише у старшому біті.
- **Друга половина** є дзеркальною копією першої, але з доданим спереду бітом `1`. Дзеркальність зберігає властивість відмінності в одному біті.
- **Перехід між останнім елементом першої половини і першим елементом другої половини**:
  - Останній код першої половини має префікс `0`.
  - Перший код другої половини є його дзеркальним аналогом, але з префіксом `1`.
  - Всі інші біти залишаються незмінними, тобто ці два коди також відрізняються рівно в одному біті.

Отже, індукційно доведено, що алгоритм будує коректну послідовність коду Ґрея для будь-якого `n`.

## Аналіз часової складності

Позначимо:
- `n` — кількість бітів у коді Ґрея.
- `2^n` — кількість кодів у послідовності.

### Обчислення складності

На кожному рівні `k` рекурсії формується `2^k` рядків довжини `k`. Таким чином:

`T(n) = 2 * T(n - 1) + O(2^n)`

Розв'язуючи це рівняння, отримуємо:

`T(n) = O(n * 2^n)`

Отже, алгоритм працює правильно, хоча його часова складність зростає дуже швидко зі збільшенням `n`.


---

## Завдання 2: Виконання задач з LeetCode
### Виконані задачі:
1. [Evaluate Reverse Polish Notation](https://leetcode.com/problems/evaluate-reverse-polish-notation/solutions/6505505/solution-to-evaluate-reverse-polish-nota-7ez4/)
2. [Permutations](https://leetcode.com/problems/permutations/solutions/6505516/solution-to-permutations-by-anhkmc2tmy-8joh/)



