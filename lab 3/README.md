# Частина 1 Сортування злиттям

## Завдання 1.1

### 1. Побудова рекурсивного дерева викликів

### Дерево викликів:
```
([a1, a2, a3, a4, a5]):

    ([а1, а2, а3]):

        ([а1, а2]):

            ([а1])
            ([а2]) 

        ([а3]) 

    ([а4, а5]):

        ([а4])
        ([а5])

```

---

## 2. Рекурсивний псевдокод

```plaintext
ФУНКЦІЯ MergeSort(Масив A, Ліва межа l, Права межа r):
    ЯКЩО l ≥ r:
        ПОВЕРНУТИСЬ

    СЕРЕДИНА m = (l + r) // 2
    
    MergeSort(A, l, m)      
    MergeSort(A, m + 1, r)  
    Merge(A, l, m, r)       

ФУНКЦІЯ Merge(Масив A, Ліва межа l, Середина m, Права межа r):
    Створити тимчасові масиви L і R
    Скопіювати елементи A[l..m] у L
    Скопіювати елементи A[m+1..r] у R

    Індекси i = 0, j = 0, k = l

    ПОКИ i < розмір L І j < розмір R:
        ЯКЩО L[i] ≤ R[j]:
            A[k] = L[i]
            i = i + 1
        ІНАКШЕ:
            A[k] = R[j]
            j = j + 1
        k = k + 1

    ПОКИ i < розмір L:
        A[k] = L[i]
        i = i + 1
        k = k + 1

    ПОКИ j < розмір R:
        A[k] = R[j]
        j = j + 1
        k = k + 1
```

## Завдання 1.2

### Ітеративний алгоритм сортування злиттям

```plaintext
ФУНКЦІЯ IterativeMergeSort(Масив A):
    n = довжина(A)

    Розмір підмасиву s = 1
    ПОКИ s < n:
        ПОЧАТКОВА індексація i = 0
        ПОКИ i + s < n:
            Ліва межа l = i
            Права межа r = мінімум(i + 2*s - 1, n - 1)
            Середина m = i + s - 1
            
            Якщо r > m:
                Merge(A, l, m, r)
            
            i = i + 2 * s

        Розмір підмасиву s = 2 * s

ФУНКЦІЯ Merge(Масив A, Ліва межа l, Середина m, Права межа r):
    Створити тимчасові масиви L і R
    Скопіювати елементи A[l..m] у L
    Скопіювати елементи A[m+1..r] у R

    Індекси i = 0, j = 0, k = l

    ПОКИ i < розмір L І j < розмір R:
        ЯКЩО L[i] ≤ R[j]:
            A[k] = L[i]
            i = i + 1
        ІНАКШЕ:
            A[k] = R[j]
            j = j + 1
        k = k + 1

    ПОКИ i < розмір L:
        A[k] = L[i]
        i = i + 1
        k = k + 1

    ПОКИ j < розмір R:
        A[k] = R[j]
        j = j + 1
        k = k + 1
```

## Завдання 1.3

[Реалізація](./1-3.py)

Результат тестування масиву з 999999 елементами:

```plaintext
Time taken for Recursive Sort: 4.718166 seconds
Time taken for Iterative Sort: 4.851185 seconds
----------------------------------------
```

### 1. Аналіз

#### Проєктування алгоритму

- **Рекурсивний підхід**: Простий і інтуїтивно зрозумілий завдяки принципу "розділяй і володарюй". Поділ на підмасиви та злиття природно відображаються через рекурсію.
  
- **Ітеративний підхід**: Більш складний, оскільки вимагає використання циклів і додаткових структур для злиття підмасивів.

#### Програмна реалізація

- **Рекурсивний підхід**: Код коротший і більш читабельний, але може призвести до переповнення стеку при великих масивах.
  
- **Ітеративний підхід**: Складніший, вимагає більше циклів і маніпуляцій з масивами, але не має проблеми з переповненням стеку і може бути більш ефективним для великих даних.

#### Теоретична часова складність

- **Рекурсивний підхід**: Часова складність **O(n log n)**, просторова складність **O(n)** через використання додаткових масивів.
  
- **Ітеративний підхід**: Часова складність теж **O(n log n)**, але може бути ефективнішим через менші накладні витрати на стек.

### 2. Порівняння підходів

   **Рекурсивний підхід**:
   - **Переваги**: Простота, зрозумілість.
   - **Недоліки**: Можливість переповнення стеку, додаткові накладні витрати на рекурсивні виклики.

   **Ітеративний підхід**:
   - **Переваги**: Відсутність переповнення стеку, менші вимоги до пам'яті для великих масивів.
   - **Недоліки**: Складніший код, менш інтуїтивно зрозумілий.

## Завдання 1.4

[Реалізація](./1-4.py)

Результат тестування масиву з 999999 елементами:

```plaintext
Time taken for Recursive Sort: 4.768912 seconds
Time taken for Iterative Sort: 4.876251 seconds
Time taken for Optimized Merge Sort: 3.871991 seconds
----------------------------------------
```

### Аналіз:

- **Часова складність**: Усі три підходи мають **O(n log n)**, але оптимізоване сортування використовує сортування вставками для малих підмасивів, що знижує накладні витрати на малих масивах.
  
- **Практична ефективність**: Оптимізоване сортування злиттям працює швидше, зменшуючи час виконання порівняно з рекурсивним та ітеративним методами.

- **Пам'ять**: Усі три методи використовують **O(n)** пам'яті, але оптимізація може зменшити потребу в пам'яті на малих підмасивах.


## Завдання 1.5

- **Рекурсивний підхід** є простішим для розуміння і проєктування алгоритму, а також для написання коду, завдяки своїй чіткій та логічній структурі.
- **Ітеративний підхід** потребує більше часу на розуміння і реалізацію через складнішу логіку злиття підмасивів.

# Частина 2 «Задача комівояжера»

### Опис задачі

#### Вхідні дані:
- **Множина міст**: `V = { v1, v2, ..., vn }`, де `n`.
- **Матриця відстаней (вартостей)**: ` C = [cij] `, матриця розміру ` n х n `, де ` cij є R >= 0 ` і ` cii = 0 ` для всіх ` i `.
- **Симетрія матриці**: ` cij = cji ` для всіх ` i, j є {1, ..., n} `, тобто відстані між містами однакові у обох напрямках.

#### Мета:
Знайти цикл, який починається і закінчується в одному місті (наприклад, ` v1 `), проходить через всі інші міста рівно один раз, і мінімізує загальну вартість маршруту.

#### Приклад:
**Вхідні дані (матриця відстаней для 4 міст):**

```
4
0   10  15  20
10  0   35  25
15  35  0   30
20  25  30  0
```

**Очікуваний вихід (оптимальний маршрут і його довжина):**

```
Оптимальний цикл: 1 → 2 → 4 → 3 → 1
Загальна довжина = 80
```

### Псевдокод:

```plaintext
ФУНКЦІЯ BruteForceTSP(Матриця відстаней C):
    n = кількість міст (рядки або стовпці в C)
    найкраща_вартість = нескінченість
    найкращий_маршрут = []

    # Генерація всіх перестановок міст (окрім першого міста, яке фіксоване)
    Генерація перестановок маршрутів = Генерувати всі перестановки для {2, 3, ..., n} 

    # Перебір кожного можливого маршруту
    ДЛЯ кожного маршруту route у Генерація перестановок маршрутів:
        поточна_вартість = 0
        ПОКИ i = 1 ДО n-1:
            поточна_вартість = поточна_вартість + C[route[i-1], route[i]]

        поточна_вартість = поточна_вартість + C[route[n-1], route[0]]

        # Оновлення найкращого маршруту
        ЯКЩО поточна_вартість < найкраща_вартість:
            найкраща_вартість = поточна_вартість
            найкращий_маршрут = route

    ПОВЕРНУТИ найкращий_маршрут, найкраща_вартість

```

### Аналіз складності

#### Часова складність:
Алгоритм перебирає всі перестановки міст (окрім першого), що дає кількість перестановок  `(n-1)!`. Для кожної перестановки обчислюється вартість маршруту, що займає `O(n)` часу. Отже, загальна часова складність алгоритму становить `O(n!)`.

#### Просторова складність:
Алгоритм використовує `O(n)` додаткової пам'яті для зберігання поточного маршруту та допоміжних змінних.

Цей алгоритм має експоненційну часову складність і є непрактичним для великих значень `n`.


### Код:

[Реалізація](./brute.py)

# Частина 3 «Максимальний підмасив»

[Loom](https://www.loom.com/share/8ac54c1b478f4720b5bf7fb51c6f1eba)
[LeetCode](https://leetcode.com/problems/maximum-subarray/submissions/1593064689/)

